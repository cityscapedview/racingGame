<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Racing Game</title>
  </head>
  <body>
    <canvas id="gameCanvas" width="800" height="600"></canvas>

    <script>
      let ballX = 75;
      let ballY = 75;
      let ballSpeedX = 5;
      let ballSpeedY = 7;

      const BRICK_W = 80;
      const BRICK_H = 20;
      const BRICK_GAP = 2;
      const BRICK_COLS = 10;
      const BRICK_ROWS = 14;
      let brickGrid = new Array(BRICK_COLS * BRICK_ROWS);
      let bricksLeft = 0;

      let canvas, canvasContext;

      let mouseX = 0;
      let mouseY = 0;

      function updateMousePos(evt) {
        let rect = canvas.getBoundingClientRect();
        let root = document.documentElement;

        mouseX = evt.clientX - rect.left - root.scrollLeft;
        mouseY = evt.clientY - rect.top - root.scrollTop;

        // cheat / hack to test ball in any position
        // ballX = mouseX;
        // ballY = mouseY;
        // ballSpeedX = 4;
        // ballSpeedY = -4;
      }

      function brickReset() {
        bricksLeft = 0;
        var i;
        for (var i = 0; i < 3 * BRICK_COLS; i++) {
          brickGrid[i] = false;
        }
        for (; i < BRICK_COLS * BRICK_ROWS; i++) {
          brickGrid[i] = true;
          bricksLeft++;
        } // end of for each brick
      } // end of brickReset func

      window.onload = function () {
        canvas = document.getElementById("gameCanvas");
        canvasContext = canvas.getContext("2d");

        let framesPerSecond = 30;
        setInterval(updateAll, 1000 / framesPerSecond);

        canvas.addEventListener("mousemove", updateMousePos);

        brickReset();
        ballReset();
      };

      function updateAll() {
        moveAll();
        drawAll();
      }

      function ballReset() {
        ballX = canvas.width / 2;
        ballY = canvas.height / 2;
      }

      function ballMove() {
        ballX += ballSpeedX;
        ballY += ballSpeedY;

        if (ballX < 0 && ballSpeedX < 0.0) {
          //left
          ballSpeedX *= -1;
        }
        if (ballY < 0 && ballSpeedY < 0.0) {
          //Top
          ballSpeedY *= -1;
        }
        if (ballX > canvas.width && ballSpeedX > 0.0) {
          //right
          ballSpeedX *= -1;
        }
        if (ballY > canvas.height) {
          //bottom
          ballReset();
          brickReset();
        }
      }

      function isBrickAtColRow(col, row) {
        if (col >= 0 && col < BRICK_COLS && row >= 0 && row < BRICK_ROWS) {
          let brickIndexUnderCoord = rowColToArrayIndex(col, row);
          return brickGrid[brickIndexUnderCoord];
        } else {
          return false;
        }
      }

      function ballBrickHandling() {
        let ballBrickCol = Math.floor(ballX / BRICK_W);
        let ballBrickRow = Math.floor(ballY / BRICK_H);
        let brickIndexUnderBall = rowColToArrayIndex(
          ballBrickCol,
          ballBrickRow
        );

        if (
          ballBrickCol >= 0 &&
          ballBrickCol < BRICK_COLS &&
          ballBrickRow >= 0 &&
          ballBrickRow < BRICK_ROWS
        ) {
          if (isBrickAtColRow(ballBrickCol, ballBrickRow)) {
            brickGrid[brickIndexUnderBall] = false;
            bricksLeft--;
            console.log(bricksLeft);

            let prevBallX = ballX - ballSpeedX;
            let prevBallY = ballY - ballSpeedY;
            let prevBrickCol = Math.floor(prevBallX / BRICK_W);
            let prevBrickRow = Math.floor(prevBallY / BRICK_H);

            var bothTestsFailed = true;

            if (prevBrickCol != ballBrickCol) {
              if (isBrickAtColRow(prevBrickCol, ballBrickRow) == false) {
                ballSpeedX *= -1;
                bothTestsFailed = false;
              }
            }
            if (prevBrickRow != ballBrickRow) {
              if (isBrickAtColRow(ballBrickCol, ballBrickRow) == false) {
                ballSpeedY *= -1;
                bothTestsFailed = false;
              }
            }

            if (bothTestsFailed) {
              // armpit case, prevents ball from going through 45 degree corner.
              ballSpeedX *= -1;
              ballSpeedY *= -1;
            }
          } // end of brick found
        } // end of valid col and row
      } // end of ballBrickHandling function

      function moveAll() {
        ballMove();

        ballBrickHandling();
      }

      function rowColToArrayIndex(col, row) {
        return col + BRICK_COLS * row;
      }

      function drawBricks() {
        for (let eachRow = 0; eachRow < BRICK_ROWS; eachRow++) {
          for (let eachCol = 0; eachCol < BRICK_COLS; eachCol++) {
            var arrayIndex = rowColToArrayIndex(eachCol, eachRow);

            if (brickGrid[arrayIndex]) {
              colorRect(
                BRICK_W * eachCol,
                BRICK_H * eachRow,
                BRICK_W - BRICK_GAP,
                BRICK_H - BRICK_GAP,
                "blue"
              );
            } // end of is this brick here
          } // end of for each brick
        } // end of eachRow
      } // end of drawBricks() func

      function drawAll() {
        //clear screen
        colorRect(0, 0, canvas.width, canvas.height, "black");

        //draw ball
        colorCircle(ballX, ballY, 10, "white");

        drawBricks();
      }

      function colorRect(topLeftX, topLeftY, boxWidth, boxHeight, fillColor) {
        canvasContext.fillStyle = fillColor;
        canvasContext.fillRect(topLeftX, topLeftY, boxWidth, boxHeight);
      }

      function colorCircle(centerX, centerY, radius, fillColor) {
        canvasContext.fillStyle = fillColor;
        canvasContext.beginPath();
        canvasContext.arc(centerX, centerY, radius, 0, Math.PI * 2, true);
        canvasContext.fill();
      }

      function colorText(showWords, textX, textY, fillColor) {
        canvasContext.fillStyle = fillColor;
        canvasContext.fillText(showWords, textX, textY);
      }
    </script>
  </body>
</html>
